# Cline Rules for EtoAudioBook Project

## Project Context
React + Flask web application for converting text documents into multi-voice audiobooks using Google Cloud Text-to-Speech API.

## Core Technologies
- **Backend**: Flask (Python 3.12), Google Cloud TTS, python-dotenv
- **Frontend**: React 19.1.1, Create React App, JavaScript
- **Development**: VS Code with extensions, pytest, ESLint, Prettier
- **Cloud**: Google Cloud Platform with service account authentication

## Project Structure
```
EtoAudioBook - Copy/
├── Backend/               # Flask API server
│   ├── app.py            # Main Flask application
│   ├── credentials.py    # Environment-based credential management  
│   ├── requirements.txt  # Python dependencies
│   ├── .env             # Environment variables (gitignored)
│   └── venv/            # Python virtual environment
├── Frontend/             # React application
│   ├── src/             # React source code
│   ├── public/          # Static assets  
│   ├── package.json     # Node dependencies
│   └── build/           # Production build (gitignored)
├── docs/                # Project documentation
├── mcp.json            # MCP server configuration
└── Makefile            # Development automation
```

## Development Guidelines

### Python Backend Rules
- **Code Style**: Use Black formatter with 88-character line limit
- **Imports**: Organize with isort, external libraries first
- **Type Hints**: Use for all function parameters and return values
- **Error Handling**: Use specific exceptions, log with context
- **Naming**: snake_case for functions/variables, PascalCase for classes
- **Security**: Never hardcode credentials, use environment variables only

### React Frontend Rules  
- **Components**: Use functional components with hooks, not classes
- **State Management**: useState and useEffect for local state
- **Code Style**: Prettier with 2-space indentation, trailing commas
- **Naming**: camelCase for variables/functions, PascalCase for components
- **Async Operations**: Use async/await, not .then() chains
- **Props**: Destructure props in component parameters

### File Management
- **Gitignore**: All credential files, .env files, build artifacts
- **Environment**: Separate .env files for different environments
- **Dependencies**: Keep requirements.txt and package.json updated
- **Virtual Environment**: Always use Backend/venv for Python

## API Design Standards

### Endpoint Structure
- `POST /api/detect-roles` - Parse text and extract character roles
- `GET /api/voices` - Retrieve available TTS voices
- `POST /api/synthesize` - Generate audio with voice assignments

### Response Format
All API responses should follow this structure:
```python
# Success
{
    "success": True,
    "data": {...},
    "message": "Description of what happened"
}

# Error
{
    "success": False, 
    "error": "User-friendly error message",
    "details": {...}  # Optional technical details
}
```

### Error Handling
- Use appropriate HTTP status codes (200, 400, 404, 500)
- Log errors with Python logging module
- Don't expose internal system details to users
- Include request context in error logs

## Text-to-Speech Implementation

### Role Detection Pattern
- Parse markdown format: `**Character Name:** dialogue text`
- Extract unique character roles from document
- Support multiple speaking parts per character
- Handle edge cases (nested quotes, punctuation)

### Voice Processing
- Map detected roles to Google Cloud TTS voices
- Support voice customization (pitch, speed, accent)
- Generate individual audio segments per role
- Combine segments into complete audiobook

### Audio Output
- Format: MP3 for web compatibility
- Quality: Standard quality for development, high for production
- Progress: Provide generation progress feedback
- Storage: Temporary files, cleanup after delivery

## Development Workflow

### Local Development
1. **Setup**: `make setup` for initial environment configuration
2. **Backend**: `cd Backend && python app.py` (runs on localhost:5000)
3. **Frontend**: `cd Frontend && npm start` (runs on localhost:3000)  
4. **Combined**: `make run-all` to start both servers simultaneously

### Code Quality
- **Formatting**: `make format` - Black for Python, Prettier for JS/React
- **Linting**: `make lint` - Flake8 for Python, ESLint for JS/React  
- **Testing**: `make test` - pytest for Backend, Jest for Frontend
- **Security**: `make check-security` - bandit and safety checks

### Version Control
- **Commits**: Use conventional commit format
- **Branches**: Feature branches for new development
- **Pull Requests**: Required for main branch changes
- **Credentials**: Never commit secrets or keys

## Testing Strategy

### Backend Testing (pytest)
- **Unit Tests**: Test business logic in isolation
- **Integration Tests**: Test API endpoints with mock data
- **TTS Mocking**: Mock Google Cloud TTS API calls
- **Coverage**: Aim for >80% code coverage
- **Fixtures**: Use pytest fixtures for test data

### Frontend Testing (Jest + React Testing Library)
- **Component Tests**: Test user interactions and rendering
- **Integration Tests**: Test API integration with mock responses
- **User Flow Tests**: Test complete user workflows
- **Accessibility**: Test screen reader compatibility

## Security Requirements

### Credential Management
- **Environment Variables**: All secrets in .env files
- **Service Account**: Use Google Cloud service account JSON
- **Git**: credentials.py and .env files must be gitignored
- **Production**: Use Google Secret Manager for production secrets

### Input Validation
- **File Uploads**: Validate file types and sizes
- **Text Processing**: Sanitize user-provided text content
- **API Requests**: Validate all request parameters
- **Error Messages**: Don't expose internal system details

## Performance Considerations

### Backend Optimization
- **Async Operations**: Use async processing for TTS generation
- **Chunking**: Split large text into manageable segments
- **Caching**: Cache voice lists and common responses
- **Resource Management**: Clean up temporary files promptly

### Frontend Optimization  
- **Loading States**: Show progress for long-running operations
- **Error Boundaries**: Graceful error handling for components
- **File Handling**: Progressive file upload for large documents
- **Audio Playback**: Efficient audio streaming and controls

## Common Patterns to Follow

### Flask Route Pattern
```python
@app.route('/api/endpoint', methods=['POST'])
def endpoint_handler():
    try:
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': 'No data provided'}), 400
        
        result = process_request(data)
        return jsonify({'success': True, 'data': result})
        
    except ValidationError as e:
        return jsonify({'success': False, 'error': str(e)}), 400
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return jsonify({'success': False, 'error': 'Internal server error'}), 500
```

### React Component Pattern
```javascript
const ComponentName = ({ prop1, prop2 }) => {
  const [state, setState] = useState(initialValue);
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    // Side effects here
  }, [dependencies]);
  
  const handleAction = async () => {
    setLoading(true);
    try {
      const response = await api.call();
      setState(response.data);
    } catch (error) {
      console.error('Action failed:', error);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div>
      {/* Component JSX */}
    </div>
  );
};
```

## Debugging Guidelines
- **Backend**: Use Python logging with appropriate levels (INFO, ERROR)
- **Frontend**: Use browser DevTools, console.log for debugging
- **Network**: Monitor API requests/responses in Network tab
- **State**: Use React DevTools to inspect component state
- **Errors**: Check both browser console and Flask logs for issues

## Deployment Readiness
- **Environment**: Separate configurations for dev/staging/production
- **Build**: `make build` creates production-ready frontend build
- **Health Checks**: Implement `/health` endpoint for monitoring
- **Documentation**: Keep README and API documentation updated
- **Dependencies**: Regular security updates for npm and pip packages
